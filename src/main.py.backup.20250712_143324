"""
SprintReader - Main Application (FIXED Timer Integration)
PDF Reading & Note-Taking Tool with WORKING Timer and Focus Features
"""

import sys
import os
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QVBoxLayout, QWidget, 
    QMenuBar, QStatusBar, QMessageBox, QHBoxLayout,
    QPushButton, QLabel, QComboBox, QSpinBox, QFileDialog
)
from PyQt6.QtCore import Qt, QTimer
from PyQt6.QtGui import QAction, QKeySequence, QFont
from dotenv import load_dotenv

# Add the src directory to the path
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

# Load environment variables
load_dotenv()

# Import our modules
from database.models import db_manager
from ui.pdf_viewer import PDFViewerWidget
from timer.timer_manager import TimerManager, TimerMode
from focus.focus_manager import FocusManager
from analytics.analytics_manager import AnalyticsManager
from notifications.notification_manager import NotificationManager
from estimation.time_estimator import TimeEstimator
from estimation.reading_predictor import ReadingPredictor
from notes.note_manager import NoteManager

class SprintReaderMainWindow(QMainWindow):
    """Main application window with WORKING timer and note-taking features"""
    
    def __init__(self):
        super().__init__()
        self.pdf_viewer = None
        
        # Initialize managers
        self.timer_manager = TimerManager()
        self.focus_manager = FocusManager()
        self.analytics_manager = AnalyticsManager()
        self.notification_manager = NotificationManager()
        
        # Initialize time estimation
        self.time_estimator = TimeEstimator()
        self.reading_predictor = ReadingPredictor()
        
        # Initialize note manager
        self.note_manager = NoteManager()
        
        # Timer state tracking - FIXED
        self.current_timer_mode = TimerMode.REGULAR
        self.timer_active = False
        self.is_break_mode = False
        
        self.init_ui()
        self.init_database()
        self.init_menu_bar()
        self.init_toolbar()
        self.init_status_bar()
        self.init_shortcuts()
        self.connect_signals()
    
    def init_ui(self):
        """Initialize the user interface"""
        self.setWindowTitle("SprintReader - PDF Reading & Note-Taking")
        self.setGeometry(100, 100, 1800, 1000)
        
        # Create main widget and layout
        main_widget = QWidget()
        self.setCentralWidget(main_widget)
        main_layout = QVBoxLayout(main_widget)
        
        # Add timer toolbar
        self.create_timer_toolbar(main_layout)
        
        # Create and set the PDF viewer with note-taking
        self.pdf_viewer = PDFViewerWidget()
        main_layout.addWidget(self.pdf_viewer)
        
        # Connect signals
        self.pdf_viewer.document_opened.connect(self.on_document_opened)
        self.pdf_viewer.page_changed.connect(self.on_page_changed)
        if hasattr(self.pdf_viewer, 'note_created'):
            self.pdf_viewer.note_created.connect(self.on_note_created)
    
    def create_timer_toolbar(self, parent_layout):
        """Create the timer and focus controls toolbar"""
        timer_layout = QHBoxLayout()
        
        # Timer mode selection
        timer_layout.addWidget(QLabel("Timer Mode:"))
        self.timer_mode_combo = QComboBox()
        self.timer_mode_combo.addItems(["Regular", "Pomodoro", "Sprint", "Custom"])
        self.timer_mode_combo.currentTextChanged.connect(self.on_timer_mode_changed)
        timer_layout.addWidget(self.timer_mode_combo)
        
        # Custom duration
        self.custom_duration_label = QLabel("Duration:")
        self.custom_duration_spinbox = QSpinBox()
        self.custom_duration_spinbox.setRange(1, 120)
        self.custom_duration_spinbox.setValue(25)
        self.custom_duration_spinbox.setSuffix(" min")
        timer_layout.addWidget(self.custom_duration_label)
        timer_layout.addWidget(self.custom_duration_spinbox)
        
        # Initially hide custom duration controls
        self.custom_duration_label.hide()
        self.custom_duration_spinbox.hide()
        
        timer_layout.addWidget(QLabel(" | "))
        
        # Timer controls
        self.start_timer_btn = QPushButton("ğŸ… Start Session")
        self.start_timer_btn.clicked.connect(self.start_timer_session)
        timer_layout.addWidget(self.start_timer_btn)
        
        self.pause_timer_btn = QPushButton("â¸ï¸ Pause")
        self.pause_timer_btn.clicked.connect(self.pause_timer_session)
        self.pause_timer_btn.setEnabled(False)
        timer_layout.addWidget(self.pause_timer_btn)
        
        self.stop_timer_btn = QPushButton("â¹ï¸ Stop")
        self.stop_timer_btn.clicked.connect(self.stop_timer_session)
        self.stop_timer_btn.setEnabled(False)
        timer_layout.addWidget(self.stop_timer_btn)
        
        timer_layout.addWidget(QLabel(" | "))
        
        # Timer display - ENHANCED
        self.timer_display = QLabel("00:00")
        font = QFont()
        font.setBold(True)
        font.setPointSize(16)  # Larger font for better visibility
        self.timer_display.setFont(font)
        self.timer_display.setStyleSheet("""
            QLabel {
                background-color: #f0f0f0;
                border: 2px solid #ccc;
                border-radius: 8px;
                padding: 8px 16px;
                min-width: 80px;
            }
        """)
        self.timer_display.setAlignment(Qt.AlignmentFlag.AlignCenter)
        timer_layout.addWidget(self.timer_display)
        
        timer_layout.addWidget(QLabel(" | "))
        
        # Focus mode toggle
        self.focus_mode_btn = QPushButton("ğŸ¯ Focus Mode")
        self.focus_mode_btn.clicked.connect(self.toggle_focus_mode)
        self.focus_mode_btn.setCheckable(True)
        timer_layout.addWidget(self.focus_mode_btn)
        
        # Stretch to center everything
        timer_layout.addStretch()
        
        # Session info
        self.session_info_label = QLabel("ğŸ“š Ready to Focus & Take Notes")
        timer_layout.addWidget(self.session_info_label)
        
        parent_layout.addLayout(timer_layout)
    
    def init_database(self):
        """Initialize database connection"""
        try:
            db_manager.create_tables()
            session = db_manager.get_session()
            session.close()
            print("âœ… Database Connected Successfully")
        except Exception as e:
            print(f"âŒ Database Connection Error: {str(e)}")
            QMessageBox.critical(
                self, 
                "Database Error", 
                f"Failed to connect to database:\n{str(e)}"
            )
    
    def init_toolbar(self):
        """Initialize toolbar elements - FIXED"""
        # Create separate timer for UI updates
        self.ui_update_timer = QTimer()
        self.ui_update_timer.timeout.connect(self.update_timer_display)
        self.ui_update_timer.start(1000)  # Update every second
        
        print("âœ… UI update timer started")
    
    def init_menu_bar(self):
        """Initialize the menu bar"""
        menubar = self.menuBar()
        
        # File Menu
        file_menu = menubar.addMenu('&File')
        
        open_action = QAction('&Open PDF...', self)
        open_action.setShortcut(QKeySequence.StandardKey.Open)
        open_action.triggered.connect(self.pdf_viewer.open_file)
        file_menu.addAction(open_action)
        
        file_menu.addSeparator()
        
        if hasattr(self.pdf_viewer, 'export_notes'):
            export_notes_action = QAction('&Export Notes...', self)
            export_notes_action.setShortcut(QKeySequence('Ctrl+E'))
            export_notes_action.triggered.connect(self.export_current_notes)
            file_menu.addAction(export_notes_action)
        
        exit_action = QAction('E&xit', self)
        exit_action.setShortcut(QKeySequence.StandardKey.Quit)
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)
        
        # View Menu
        view_menu = menubar.addMenu('&View')
        
        focus_action = QAction('&Focus Mode', self)
        focus_action.setShortcut(QKeySequence('F11'))
        focus_action.triggered.connect(self.toggle_focus_mode)
        view_menu.addAction(focus_action)
        
        # Timer Menu
        timer_menu = menubar.addMenu('&Timer')
        
        pomodoro_action = QAction('Start &Pomodoro', self)
        pomodoro_action.setShortcut(QKeySequence('Ctrl+P'))
        pomodoro_action.triggered.connect(lambda: self.start_specific_timer(TimerMode.POMODORO))
        timer_menu.addAction(pomodoro_action)
        
        sprint_action = QAction('Start &Sprint', self)
        sprint_action.setShortcut(QKeySequence('Ctrl+Shift+S'))
        sprint_action.triggered.connect(lambda: self.start_specific_timer(TimerMode.SPRINT))
        timer_menu.addAction(sprint_action)
        
        # Notes Menu
        if hasattr(self.pdf_viewer, 'add_quick_note'):
            notes_menu = menubar.addMenu('&Notes')
            
            quick_note_action = QAction('&Quick Note', self)
            quick_note_action.setShortcut(QKeySequence('Ctrl+N'))
            quick_note_action.triggered.connect(self.pdf_viewer.add_quick_note)
            notes_menu.addAction(quick_note_action)
            
            search_notes_action = QAction('&Search Notes...', self)
            search_notes_action.setShortcut(QKeySequence('Ctrl+F'))
            search_notes_action.triggered.connect(self.search_notes)
            notes_menu.addAction(search_notes_action)
        
        # Analytics Menu
        analytics_menu = menubar.addMenu('&Analytics')
        
        daily_stats_action = QAction('&Daily Statistics', self)
        daily_stats_action.triggered.connect(self.show_daily_stats)
        analytics_menu.addAction(daily_stats_action)
        
        time_estimate_action = QAction("&Time Estimates", self)
        time_estimate_action.triggered.connect(self.show_time_estimates)
        analytics_menu.addAction(time_estimate_action)
        
        # Help Menu
        help_menu = menubar.addMenu('&Help')
        
        about_action = QAction('&About', self)
        about_action.triggered.connect(self.show_about)
        help_menu.addAction(about_action)
    
    def init_status_bar(self):
        """Initialize the status bar"""
        self.status_bar = self.statusBar()
        self.status_bar.showMessage("Ready - Open a PDF and start taking notes!")
    
    def init_shortcuts(self):
        """Initialize keyboard shortcuts"""
        pass
    
    def connect_signals(self):
        """Connect manager signals - ENHANCED"""
        print("ğŸ”— Connecting timer signals...")
        
        # Timer signals - FIXED CONNECTIONS
        self.timer_manager.timer_started.connect(self.on_timer_started)
        self.timer_manager.timer_finished.connect(self.on_timer_finished)
        self.timer_manager.timer_paused.connect(self.on_timer_paused)
        self.timer_manager.timer_resumed.connect(self.on_timer_resumed)
        self.timer_manager.timer_stopped.connect(self.on_timer_stopped)
        self.timer_manager.break_started.connect(self.on_break_started)
        self.timer_manager.break_finished.connect(self.on_break_finished)
        self.timer_manager.time_updated.connect(self.on_time_updated)
        
        # Focus mode signals
        self.focus_manager.focus_mode_enabled.connect(self.on_focus_enabled)
        self.focus_manager.focus_mode_disabled.connect(self.on_focus_disabled)
        
        # Note manager signals
        self.note_manager.note_created.connect(self.on_note_manager_note_created)
        
        print("âœ… All signals connected")
    
    # FIXED TIMER METHODS
    
    def on_timer_mode_changed(self, mode_text):
        """Handle timer mode change"""
        print(f"ğŸ”„ Timer mode changed to: {mode_text}")
        
        mode_map = {
            "Regular": TimerMode.REGULAR,
            "Pomodoro": TimerMode.POMODORO,
            "Sprint": TimerMode.SPRINT,
            "Custom": TimerMode.CUSTOM
        }
        
        self.current_timer_mode = mode_map.get(mode_text, TimerMode.REGULAR)
        
        # Show/hide custom duration controls
        is_custom = mode_text == "Custom"
        self.custom_duration_label.setVisible(is_custom)
        self.custom_duration_spinbox.setVisible(is_custom)
        
        # Update button text
        mode_icons = {"Regular": "ğŸ“–", "Pomodoro": "ğŸ…", "Sprint": "âš¡", "Custom": "â±ï¸"}
        icon = mode_icons.get(mode_text, "ğŸ“–")
        self.start_timer_btn.setText(f"{icon} Start {mode_text}")
    
    def start_timer_session(self):
        """Start a timer session - FIXED"""
        print(f"â–¶ï¸ Starting {self.current_timer_mode.value} timer session")
        
        if self.timer_active:
            print("âš ï¸ Timer already active")
            return
        
        success = False
        try:
            if self.current_timer_mode == TimerMode.POMODORO:
                success = self.timer_manager.start_pomodoro()
                print("ğŸ… Pomodoro timer started")
            elif self.current_timer_mode == TimerMode.SPRINT:
                success = self.timer_manager.start_sprint()
                print("âš¡ Sprint timer started")
            elif self.current_timer_mode == TimerMode.CUSTOM:
                duration = self.custom_duration_spinbox.value()
                success = self.timer_manager.start_custom(duration)
                print(f"â±ï¸ Custom timer started: {duration} minutes")
            else:
                # Regular mode - just track without timer
                success = True
                print("ğŸ“– Regular reading mode active")
        
            if success:
                self.timer_active = True
                self.is_break_mode = False
                self._update_timer_controls(True)
                print("âœ… Timer started successfully")
            else:
                print("âŒ Failed to start timer")
                
        except Exception as e:
            print(f"âŒ Error starting timer: {e}")
            QMessageBox.warning(self, "Timer Error", f"Failed to start timer: {str(e)}")
    
    def start_specific_timer(self, mode: TimerMode):
        """Start a specific timer mode (for menu/shortcut actions)"""
        print(f"ğŸ¯ Starting specific timer: {mode.value}")
        
        mode_index = {
            TimerMode.REGULAR: 0,
            TimerMode.POMODORO: 1,
            TimerMode.SPRINT: 2,
            TimerMode.CUSTOM: 3
        }
        
        self.timer_mode_combo.setCurrentIndex(mode_index.get(mode, 0))
        self.start_timer_session()
    
    def pause_timer_session(self):
        """Pause current timer session - FIXED"""
        print("â¸ï¸ Pause/Resume timer")
        
        try:
            if self.timer_manager.is_running():
                self.timer_manager.pause()
                self.pause_timer_btn.setText("â–¶ï¸ Resume")
                print("â¸ï¸ Timer paused")
            else:
                self.timer_manager.resume()
                self.pause_timer_btn.setText("â¸ï¸ Pause")
                print("â–¶ï¸ Timer resumed")
        except Exception as e:
            print(f"âŒ Error pausing/resuming timer: {e}")
    
    def stop_timer_session(self):
        """Stop current timer session - FIXED"""
        print("â¹ï¸ Stopping timer session")
        
        try:
            self.timer_manager.stop()
            self.timer_active = False
            self.is_break_mode = False
            self._update_timer_controls(False)
            self.timer_display.setText("00:00")
            self.timer_display.setStyleSheet("""
                QLabel {
                    background-color: #f0f0f0;
                    border: 2px solid #ccc;
                    border-radius: 8px;
                    padding: 8px 16px;
                    min-width: 80px;
                }
            """)
            self.session_info_label.setText("ğŸ“š Ready to Focus & Take Notes")
            print("âœ… Timer stopped and controls reset")
        except Exception as e:
            print(f"âŒ Error stopping timer: {e}")
    
    def update_timer_display(self):
        """Update timer display every second - COMPLETELY FIXED"""
        try:
            # Check if timer manager has any active timer
            if self.timer_manager.is_running() or self.timer_manager.get_state().name == "BREAK":
                time_str = self.timer_manager.get_formatted_time()
                self.timer_display.setText(time_str)
                
                # Update session info based on state
                state = self.timer_manager.get_state()
                if state.name == "RUNNING":
                    mode = self.timer_manager.get_current_mode().value.title()
                    self.session_info_label.setText(f"ğŸ¯ {mode} Session Active")
                    # Update timer display style for active session
                    self.timer_display.setStyleSheet("""
                        QLabel {
                            background-color: #e8f5e8;
                            border: 2px solid #4caf50;
                            border-radius: 8px;
                            padding: 8px 16px;
                            min-width: 80px;
                            color: #2e7d32;
                        }
                    """)
                elif state.name == "BREAK":
                    self.session_info_label.setText("â˜• Break Time")
                    self.is_break_mode = True
                    # Update timer display style for break
                    self.timer_display.setStyleSheet("""
                        QLabel {
                            background-color: #fff3e0;
                            border: 2px solid #ff9800;
                            border-radius: 8px;
                            padding: 8px 16px;
                            min-width: 80px;
                            color: #ef6c00;
                        }
                    """)
                elif state.name == "PAUSED":
                    self.session_info_label.setText("â¸ï¸ Session Paused")
                    # Update timer display style for paused
                    self.timer_display.setStyleSheet("""
                        QLabel {
                            background-color: #fafafa;
                            border: 2px solid #757575;
                            border-radius: 8px;
                            padding: 8px 16px;
                            min-width: 80px;
                            color: #424242;
                        }
                    """)
            elif self.timer_active and not self.timer_manager.is_running():
                # Timer is active but not running (finished)
                self.timer_display.setText("00:00")
                self.session_info_label.setText("âœ… Session Complete!")
            else:
                # No active timer
                if not self.timer_active:
                    self.timer_display.setText("00:00")
                    self.session_info_label.setText("ğŸ“š Ready to Focus & Take Notes")
                    
        except Exception as e:
            # Only log errors occasionally to avoid spam
            if hasattr(self, '_last_timer_error'):
                if self._last_timer_error != str(e):
                    print(f"âš ï¸ Timer display error: {e}")
                    self._last_timer_error = str(e)
            else:
                print(f"âš ï¸ Timer display error: {e}")
                self._last_timer_error = str(e)
    
    def _update_timer_controls(self, timer_running: bool):
        """Update timer control button states"""
        self.start_timer_btn.setEnabled(not timer_running)
        self.pause_timer_btn.setEnabled(timer_running)
        self.stop_timer_btn.setEnabled(timer_running)
        
        if not timer_running:
            self.pause_timer_btn.setText("â¸ï¸ Pause")
    
    # SIGNAL HANDLERS - ENHANCED
    
    def on_timer_started(self, mode):
        """Handle timer started signal - ENHANCED"""
        print(f"ğŸ“¢ Timer started signal received: {mode}")
        self.timer_active = True
        self._update_timer_controls(True)
        
        try:
            self.notification_manager.send_notification(
                f"ğŸ¯ {mode.title()} Started",
                "Focus session has begun. Happy reading!"
            )
        except Exception as e:
            print(f"âŒ Error sending notification: {e}")
    
    def on_timer_finished(self, mode):
        """Handle timer finished signal - ENHANCED"""
        print(f"ğŸ“¢ Timer finished signal received: {mode}")
        
        if not self.is_break_mode:
            # Work session finished
            self.timer_active = False
            self._update_timer_controls(False)
            
            QMessageBox.information(
                self,
                f"ğŸ‰ {mode.title()} Complete!",
                f"Excellent work! Your {mode} session is finished.\n\nTake a moment to reflect on what you've read."
            )
        
    def on_timer_paused(self):
        """Handle timer paused signal"""
        print("ğŸ“¢ Timer paused signal received")
        self.pause_timer_btn.setText("â–¶ï¸ Resume")
    
    def on_timer_resumed(self):
        """Handle timer resumed signal"""
        print("ğŸ“¢ Timer resumed signal received")
        self.pause_timer_btn.setText("â¸ï¸ Pause")
    
    def on_timer_stopped(self):
        """Handle timer stopped signal"""
        print("ğŸ“¢ Timer stopped signal received")
        self.timer_active = False
        self.is_break_mode = False
        self._update_timer_controls(False)
    
    def on_break_started(self, duration):
        """Handle break started signal - ENHANCED"""
        print(f"ğŸ“¢ Break started signal received: {duration} seconds")
        self.is_break_mode = True
        minutes = duration // 60
        
        try:
            self.notification_manager.send_notification(
                "â˜• Break Time!",
                f"Take a {minutes}-minute break. You've earned it!"
            )
        except Exception as e:
            print(f"âŒ Error sending break notification: {e}")
    
    def on_break_finished(self):
        """Handle break finished signal - ENHANCED"""
        print("ğŸ“¢ Break finished signal received")
        
        self.timer_active = False
        self.is_break_mode = False
        self._update_timer_controls(False)
        
        try:
            self.notification_manager.send_notification(
                "â° Break Over",
                "Ready for another focused session?"
            )
        except Exception as e:
            print(f"âŒ Error sending break end notification: {e}")
    
    def on_time_updated(self, remaining_seconds):
        """Handle time update signal - NEW"""
        print(f"ğŸ• Time updated: {remaining_seconds}s remaining")
        # This will be handled by update_timer_display() automatically
    
    # Focus Mode Methods
    def toggle_focus_mode(self):
        """Toggle focus mode on/off"""
        print("ğŸ¯ Toggling focus mode")
        
        try:
            self.focus_manager.toggle_focus_mode(self)
            is_focus = self.focus_manager.is_enabled()
            self.focus_mode_btn.setChecked(is_focus)
            self.focus_mode_btn.setText("ğŸ” Exit Focus" if is_focus else "ğŸ¯ Focus Mode")
            print(f"âœ… Focus mode: {'ON' if is_focus else 'OFF'}")
        except Exception as e:
            print(f"âŒ Error toggling focus mode: {e}")
    
    # Analytics Methods
    def show_daily_stats(self):
        """Show daily reading statistics"""
        try:
            stats = self.analytics_manager.get_daily_stats()
            
            message = f"""
ğŸ“Š Daily Reading Statistics

ğŸ“– Total Reading Time: {stats.get('total_reading_time', 0)} minutes
ğŸ“„ Pages Read: {stats.get('total_pages_read', 0)}
ğŸ”„ Sessions: {stats.get('session_count', 0)}
âš¡ Average Speed: {stats.get('average_reading_speed', 0):.1f} pages/min
â±ï¸ Longest Session: {stats.get('longest_session', 0)} minutes

Timer Mode Breakdown:
{self._format_session_types(stats.get('session_types', {}))}
            """.strip()
            
            QMessageBox.information(self, "Daily Statistics", message)
        except Exception as e:
            print(f"âŒ Error showing daily stats: {e}")
            QMessageBox.warning(self, "Analytics Error", "Unable to load daily statistics.")
    
    def show_time_estimates(self):
        """Show time estimation for current document"""
        try:
            if not hasattr(self.pdf_viewer, 'pdf_handler') or not self.pdf_viewer.pdf_handler.document_id:
                QMessageBox.information(self, "Time Estimates", "Please open a PDF document first.")
                return
            
            estimate = self.time_estimator.estimate_document_completion(
                self.pdf_viewer.pdf_handler.document_id
            )
            
            if not estimate:
                QMessageBox.warning(self, "Time Estimates", "Unable to calculate estimates.")
                return
            
            message = f"""
ğŸ“Š Smart Time Estimation

ğŸ“– Document: {estimate.get("document_title", "Unknown")}
ğŸ“„ Progress: {estimate.get("current_page", 0)} / {estimate.get("total_pages", 0)} pages ({estimate.get("progress_percent", 0)}%)

â±ï¸ Time Estimates:
â€¢ Remaining pages: {estimate.get("remaining_pages", 0)}
â€¢ Time per page: {estimate.get("avg_time_per_page_seconds", 0):.1f} seconds
â€¢ Estimated time to finish: {estimate.get("estimated_time_remaining_formatted", "Unknown")}

ğŸ“… Completion Forecast:
â€¢ At your current pace: {estimate.get("estimated_completion_date", "Unknown")[:10] if estimate.get("estimated_completion_date") else "Unknown"}
â€¢ Confidence level: {estimate.get("confidence_level", "Unknown")}

ğŸ’¡ Recommendation:
{estimate.get("recommendation", "Keep reading!")}
            """.strip()
            
            QMessageBox.information(self, "ğŸ“Š Time Estimates", message)
        except Exception as e:
            print(f"âŒ Error showing time estimates: {e}")
            QMessageBox.warning(self, "Analytics Error", "Unable to load time estimates.")
    
    def _format_session_types(self, session_types):
        """Format session types for display"""
        if not session_types:
            return "No sessions yet"
        
        formatted = []
        for session_type, count in session_types.items():
            formatted.append(f"  {session_type.title()}: {count}")
        
        return "\n".join(formatted)
    
    # Note Methods
    def search_notes(self):
        """Open note search dialog"""
        try:
            from PyQt6.QtWidgets import QInputDialog
            
            query, ok = QInputDialog.getText(self, 'Search Notes', 'Enter search terms:')
            
            if ok and query.strip():
                results = self.note_manager.search_notes(query.strip())
                
                if results:
                    result_text = f"Found {len(results)} notes:\n\n"
                    for note in results[:10]:
                        topic_name = self.note_manager.topics.get(note.topic_id, type('', (), {'name': 'Unknown'})).name
                        result_text += f"ğŸ“ {note.title}\n"
                        result_text += f"   ğŸ—‚ï¸ {topic_name} â€¢ Page {note.page_number}\n"
                        if note.excerpt:
                            excerpt = note.excerpt[:100] + "..." if len(note.excerpt) > 100 else note.excerpt
                            result_text += f"   ğŸ“„ \"{excerpt}\"\n"
                        result_text += "\n"
                    
                    if len(results) > 10:
                        result_text += f"... and {len(results) - 10} more results"
                    
                    QMessageBox.information(self, "Search Results", result_text)
                else:
                    QMessageBox.information(self, "Search Results", f"No notes found for: {query}")
        except Exception as e:
            print(f"âŒ Error searching notes: {e}")
            QMessageBox.warning(self, "Search Error", "Unable to search notes.")
    
    def export_current_notes(self):
        """Export notes for current document"""
        try:
            if hasattr(self.pdf_viewer, 'export_notes'):
                self.pdf_viewer.export_notes()
            else:
                QMessageBox.information(self, "Export Notes", "Note export feature not available yet.")
        except Exception as e:
            print(f"âŒ Error exporting notes: {e}")
            QMessageBox.warning(self, "Export Error", "Unable to export notes.")
    
    def on_note_created(self, note_id: str):
        """Handle note creation from PDF viewer"""
        print(f"ğŸ“¢ Note created: {note_id}")
        try:
            note = self.note_manager.notes.get(note_id)
            if note:
                self.notification_manager.send_notification(
                    "ğŸ“ Note Created",
                    f"Added note: {note.title}"
                )
        except Exception as e:
            print(f"âŒ Error handling note creation: {e}")
    
    def on_note_manager_note_created(self, note_id: str):
        """Handle note creation from note manager"""
        print(f"ğŸ“¢ Note manager created note: {note_id}")
    
    def on_document_opened(self, filepath: str):
        """Handle document opened event"""
        filename = os.path.basename(filepath)
        self.status_bar.showMessage(f"Opened: {filename}")
        self.setWindowTitle(f"SprintReader - {filename}")
        print(f"ğŸ“– Document opened: {filename}")
    
    def on_page_changed(self, page_num: int):
        """Handle page change event"""
        try:
            if hasattr(self.pdf_viewer, 'pdf_handler') and self.pdf_viewer.pdf_handler.total_pages > 0:
                progress = (page_num / self.pdf_viewer.pdf_handler.total_pages) * 100
                self.status_bar.showMessage(
                    f"Page {page_num} of {self.pdf_viewer.pdf_handler.total_pages} ({progress:.1f}%)"
                )
        except Exception as e:
            print(f"âŒ Error updating page info: {e}")
    
    def on_focus_enabled(self):
        """Handle focus mode enabled"""
        print("ğŸ“¢ Focus mode enabled")
        self.status_bar.showMessage("ğŸ¯ Focus Mode Active")
    
    def on_focus_disabled(self):
        """Handle focus mode disabled"""
        print("ğŸ“¢ Focus mode disabled")
        self.status_bar.showMessage("ğŸ” Focus Mode Disabled")
    
    def show_about(self):
        """Show about dialog"""
        QMessageBox.about(
            self,
            "About SprintReader",
            """
            <h3>SprintReader v4.0</h3>
            <p><b>PDF Reading & Note-Taking Tool</b></p>
            
            <p><b>Features:</b></p>
            <ul>
            <li>ğŸ“ Note-Taking System</li>
            <li>ğŸ… Pomodoro Timer</li>
            <li>âš¡ Sprint Sessions</li>
            <li>ğŸ¯ Focus Mode</li>
            <li>ğŸ“Š Reading Analytics</li>
            <li>â±ï¸ Time Estimation</li>
            <li>ğŸ’¾ Local Data Storage</li>
            </ul>
            
            <p><b>Keyboard Shortcuts:</b></p>
            <ul>
            <li>Ctrl+O: Open PDF</li>
            <li>Ctrl+P: Start Pomodoro</li>
            <li>Ctrl+Shift+S: Start Sprint</li>
            <li>F11: Toggle Focus Mode</li>
            <li>â†/â†’: Previous/Next Page</li>
            </ul>
            """
        )
    
    def closeEvent(self, event):
        """Handle application close event"""
        print("ğŸ‘‹ SprintReader closing...")
        
        # Stop any active timers
        if self.timer_active:
            try:
                self.timer_manager.stop()
                print("â¹ï¸ Timer stopped on close")
            except Exception as e:
                print(f"âŒ Error stopping timer on close: {e}")
        
        # Close managers
        try:
            self.analytics_manager.close()
            self.time_estimator.close()
            self.reading_predictor.close()
        except Exception as e:
            print(f"âŒ Error closing managers: {e}")
        
        event.accept()

def main():
    """Main application entry point"""
    print("ğŸš€ Starting SprintReader...")
    
    try:
        # Create QApplication
        app = QApplication(sys.argv)
        app.setApplicationName("SprintReader")
        app.setApplicationVersion("4.0.0")
        app.setOrganizationName("SprintReader")
        app.setStyle('Fusion')
        
        # Create main window
        window = SprintReaderMainWindow()
        window.show()
        
        print("âœ… SprintReader launched successfully!")
        print("ğŸ“ Features: Timer modes, Focus mode, Note-taking, Analytics")
        print("ğŸ“– Use Ctrl+O to open a PDF file")
        print("ğŸ… Use Ctrl+P for Pomodoro timer")
        print("âš¡ Use Ctrl+Shift+S for Sprint timer")
        print("ğŸ¯ Use F11 for Focus mode")
        print("â±ï¸ Timer should now work properly!")
        
        # Run the application
        sys.exit(app.exec())
        
    except Exception as e:
        print(f"âŒ Error starting SprintReader: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()